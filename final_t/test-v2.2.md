# Yat_Casched v2.2 开发文档 (最终确认版)

## 0. 核心架构

本方案是 v2.1 思想的深化和工程化落地，其核心架构由两大数据结构支撑：

1.  **历史表 (History Table)**：
    *   **功能**：作为计算 `Recency` 和 `Impact` 的唯一数据源。
    *   **实现**：每个核心维护一个 `cpu_history_table`，内部使用**双向链表** `time_list` 按时间戳升序串联所有历史记录。
    *   **查询方式**：通过从链表尾部反向遍历，可以高效地实现区间统计（如 `sum_exec_time_since`）。

2.  **加速表 (Accelerator Table)**：
    *   **功能**：作为调度决策的缓存，避免在决策的关键路径上进行重复、昂贵的 `Recency` 计算。它缓存了（任务，核心）对的“利己” `benefit` 值。
    *   **实现**：一个全局的**哈希表** `accelerator_table`。Key 由任务指针和核心 ID 组合而成，Value 是包含 `benefit` 值的 `accelerator_entry` 结构体。
    *   **工作模式**：在每次调度开始时，清空并重新计算填充。

---

## 1. 主调度流程

调度流程被清晰地划分为两个阶段：**填充**和**决策**。

### 阶段一：填充加速表 (`update_accelerator_table`)

1.  **清空**：遍历并释放 `accelerator_table` 中的所有旧条目。
2.  **遍历计算**：
    *   遍历 `yat_ready_job_pool` 中的每一个待调度任务 `p`。
    *   遍历所有**空闲的**在线核心 `cpu`。
    *   对于每一个 `(p, cpu)` 对，执行以下操作：
        *   调用 `calculate_recency(p, cpu)`，该函数会查询**历史表**。
        *   根据 `recency` 计算出 `benefit` 值。
        *   如果 `benefit > 0`，则创建一个 `accelerator_entry`，并将其添加到哈希表中。

### 阶段二：调度决策 (`schedule_yat_casched_tasks`)

1.  **调用填充**：首先调用 `update_accelerator_table()` 确保加速表为最新状态。
2.  **第一轮决策 (比拼 Benefit)**：
    *   遍历整个**加速表**，找到所有条目中最大的 `max_benefit` 值。
3.  **第二轮决策 (比拼 Impact)**：
    *   再次遍历整个**加速表**。
    *   只关注那些 `benefit == max_benefit` 的条目。
    *   对于这些“冠军候补”，实时调用 `calculate_impact()` 计算其“利他”影响。
    *   选择 `impact` 值最小的那个条目作为最终的 `best_entry`。
4.  **执行调度**：
    *   如果找到了 `best_entry`，则将其对应的任务从就绪池中移除，并分配到其对应的核心上。
    *   唤醒目标核心，触发真正的上下文切换。

---

## 2. 关键函数实现要点

### `sum_exec_time_since`
-   **必须**从链表尾部 (`list_for_each_entry_reverse`) 开始向前遍历。
-   当遇到记录的 `timestamp` 小于等于查询区间的 `start_ts` 时，即可 `break` 循环，这是关键的性能保证。

### `calculate_impact`
-   这是一个高开销函数，**只应**在 `benefit` 打破平局时调用。
-   其内部需要遍历就绪池中的其他任务，模拟将当前任务 `p` 放置到核心 `cpu` 后，对其他任务 `benefit` 的负面影响。

### `balance_yat_casched`
-   作为主调度的入口，通常只在某个指定的核心（如 CPU 0）上触发，以避免多核同时执行全局调度逻辑造成的锁竞争和冲突。

---

## 3. 方案优势与总结

这个最终确认的架构兼顾了**数据的实时性**和**决策的效率**：

-   **实时性**：`Recency` 和 `Impact` 的计算总是基于最新的历史表数据，保证了决策的准确性。
-   **效率**：通过 `accelerator_table` 缓存了高频计算的 `benefit` 值，避免了在决策循环中反复查询历史表。`Impact` 的惰性计算也显著降低了开销。
-   **结构清晰**：历史表负责“记录”，加速表负责“决策缓存”，职责分明，易于理解和维护。

这是一个逻辑严谨、实现清晰、在理论和工程上都较为均衡的调度器方案。

---

## 4. 测试与验证

为了验证 `Yat_Casched` 调度器的功能和性能，我们采用 QEMU 虚拟机进行模拟测试。测试流程包括：编译测试程序、制作 CPIO 根文件系统、编写启动脚本。

### 4.1 测试程序 (`test_yat.c`)

编写一个专用的测试程序，用于创建多个符合 `SCHED_YAT_CASCHED` 调度策略的实时任务。

- **功能**:
  - 使用 `sched_setscheduler()` 将一组线程或进程设置为 `SCHED_YAT_CASCHED` 策略。
  - 每个任务执行一个循环，打印自身的 PID 和当前运行的 CPU 核心号，以便观察调度行为。
  - 可以通过 `dmesg` 输出关键信息，方便在宿主机上查看。

### 4.2 根文件系统制作 (`mkcpio.sh`)

使用一个脚本自动化创建 `initramfs`：

1.  **创建目录结构**: 建立一个临时的根文件系统目录 `_rootfs`。
2.  **编译测试程序**: 静态编译 `test_yat.c`，确保其在最小环境中无依赖运行。
3.  **准备 `init` 脚本**:
    -   该脚本是内核启动后执行的第一个用户空间程序。
    -   负责挂载 `/proc`, `/sys` 等虚拟文件系统。
    -   执行测试程序 `test_yat`。
    -   最后启动一个 shell (`/bin/sh`)，方便手动交互和调试。
4.  **打包 CPIO**: 将 `_rootfs` 目录打包成 `rootfs.cpio` 文件。

### 4.3 QEMU 启动脚本 (`run_qemu.sh`)

使用脚本启动 QEMU，加载我们编译的内核和制作的根文件系统。

- **内核**: `-kernel arch/x86/boot/bzImage`
- **初始内存盘**: `-initrd rootfs.cpio`
- **核心参数**: `-smp N` (指定CPU核心数), `-m SIZE` (指定内存大小)
- **控制台输出**: `-nographic -append "console=ttyS0"` 将内核日志和控制台重定向到当前终端，方便观察。

通过执行 `run_qemu.sh`，我们可以启动一个完整的测试环境，并通过内核日志和测试程序的输出来验证 `Yat_Casched` 调度器的行为是否符合预期设计。

### 4.4 v2.2 针对性测试 (`yat_v2_2_test.c`)

为了精准验证 v2.2 架构的核心机制（Benefit vs Impact），我们设计了一个新的、更有针对性的测试程序。该程序取代了通用的测试套件，专注于模拟能够触发关键决策路径的场景。

- **测试场景 1: Benefit 机制验证**
  - **目的**: 验证调度器是否会为了最大化 `benefit` 而将任务调度到其缓存已经“预热”的核心上。
  - **方法**:
    1.  运行一个任务，使其在某个CPU（如CPU A）上执行并退出，从而在该CPU的缓存中留下足迹。
    2.  短暂等待后，再次运行该任务。
  - **预期结果**: 第二次运行时，调度器计算得出在 CPU A 上运行的 `benefit` 值最高，因此任务应再次被调度到 CPU A。

- **测试场景 2: Impact 机制验证**
  - **目的**: 验证当多个（任务, 核心）对具有相同的最大 `benefit` 值时，调度器是否能通过计算 `impact` 来做出最优选择，避免任务间的缓存争抢。
  - **方法**:
    1.  **预热**: 使用 `sched_setaffinity` 强制任务A在CPU 1上运行，任务B在CPU 2上运行。这使得两个CPU上分别有了A和B的缓存数据。
    2.  **冲突**: 同时启动任务A和任务B，此时对于任务A，在CPU 1上运行的`benefit`最高；对于任务B，在CPU 2上运行的`benefit`最高。这很可能形成一个平局（tie）。
  - **预期结果**: 调度器会计算将A放到CPU 2上对B的负面影响（Impact），反之亦然。为了最小化总体`impact`，调度器应做出最优决策：将A调度到CPU 1，B调度到CPU 2，从而避免冲突。

这个新的测试脚本提供了更清晰的因果验证，能直接反映 v2.2 设计文档中描述的核心调度逻辑是否正确实现。
